---
layout: post
title: "A Quiet Defense of Patterns"
---

{{ page.title }}
================

<p class="meta">Twenty years late to the party.</p>

I find myself coming back to [Patterns of Software](http://www.dreamsongs.com/Files/PatternsOfSoftware.pdf) every few years. Nearly every time I'm struggling with a code review, I think about it. I wouldn't necessarily recommend the whole thing, but it's worth reading some of the essays. One great part is the frontmatter: a short debate between the author and Christopher Alexander, first author of the much-celebrated *A Pattern Language*. 

> The elements of this language are entities called patterns. Each pattern describes a problem which occurs over and over in our environment, and then describes the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice. - *A Pattern Language*, Alexander et al

In some programming circles, Alexander's book is a book to have read, treated almost with religious reverence. A kind of Tao Te Ching of oblique programming anecdotes. A source of in-jokes and unhelpful advice. It's also a source of conflict for this same group, because it was the inspiration for something they universally revile: the [Gang of Four](http://en.wikipedia.org/wiki/Design_Patterns) book. 

> No design patterns are necessary. In any language. - [Jan Hudec](http://programmers.stackexchange.com/a/157946/92093)

When Design Patterns first came out, back in the mid-90s, it captivated me. My access to technical books was a bit limited, and I didn't have a copy of the book itself, but for a short time I was obsessed with the debate about it. It incited anger, it incited self-righteoussness, it incited smugness about *missing language features*. For each of these loud critics, it seemed to have an equally strong supporter. From the community's reaction, I couldn't wait to read *Design Patterns*. Judging by the controversy, I felt like it must be a deeply important book, with something profound to say about software and those who build it.

> As for literary criticism in general: I have long felt that any reviewer who expresses rage and loathing for a novel or a play or a poem is preposterous. He or she is like a person who has put on full armor and attacked a hot fudge sundae or a banana split - Kurt Vonnegut

In my mind, Erich Gamma was a Martin Luther figure. He had written a book that was creating a whole new church, ripping open old wounds and providing new courage to both sides. Imagine my disappointment when I finally got my hands on a copy. Instead of Luther's protest, I found a taxonomy written by stamp collectors.

> My overall bias is that technology, science, engineering, and company organization are all secondary to the people and human concerns in the endeavor. Companies, ideas, processes, and approaches ultimately fail when humanity is forgotten, ignored, or placed second. Alexander knew this, but his followers in the software pattern language community do not. Computer scientists and developers donâ€™t seem to know it, either. - Richard P Gabriel

Gabriel is right about how many of us have missed the point of Alexander's work. We've seen it as an exercise in taxonomy, or phylogeny, and missed the fact that it's primarily a human, rather than technical, endevour. We should go looking for that aspect of it again, because the human side of our field is broken, and we could use all the help we could get. We've also missed the range of scale of Alexander's work, concerned with patterns from the deeply technical to broad ideas with scope across entire societies. To live up to Alexander's vision in our own field we would need to be doing something much deeper than the Gang of Four, or their critics, did. *Design Patterns* isn't software's *A Pattern Language*.

> The more we can feel all the connections in the language, the more rich and subtle are the things we say at the most ordinary times.

*Design Patterns* isn't software's *A Pattern Language*, but it doesn't have to be to be useful. Classification and naming is an extraordinarily useful exercise. The most obvious way that it's useful is in enabling high-bandwidth conversation by building shared context. Two people with a common taxonomy of patterns find it easier to communicate - even if the goal of the communication is to reject certain patterns - than those without one. Another advantage, and common area of criticism, is in education. Teaching common patterns can make people more effective communicators more quickly, and naming and classifying patterns makes them easier to teach.

A third advantage, perhaps less obvious, is that writing down our shared context lowers the barrier to entry. High bandwidth conversations being critical to the efficiency of the software development process, any group of software engineers will build a shared context. Context then becomes an impenetrable shield, that makes it more difficult to bring others into the group. Whether we intend it or not, this can make groups appear intentionally exclusive or exclusionary.

> Functional languages are extremely expressive. In a functional language one does not need design patterns because the language is likely so high level, you end up programming in concepts that eliminate design patterns all together. - [Slava Akhmechet](http://www.defmacro.org/ramblings/fp.html)

Context is a powerful tool for aiding communication, but isn't a replacement for communication. Describing and naming patterns is a powerful way to build context, but is not exhaustive. There is no risk of getting to the point where we have described all patterns, and reduced all communication to references to patterns. At the same time, a list of patterns isn't a monotonically growing thing. Patterns are frequently split, combined, superseded, replaced, destroyed or forgotten.

Patterns themselves are also dependent on context. Some apply well to object-orientated programming, some to functional programming, some to running design meetings, some to mentoring and some to building large-scale systems. This isn't a weakness of the idea of patterns, but a strength. They are sensitive to scale, too. Some patterns of success at one scale, or in one context, may be patterns of failure at another scale, or in another context. Claims that a particular list of patterns is complete, either in support or criticism, are likely wrong.

> 16 of 23 patterns have qualitatively simpler implementation in Lisp or Dylan than in C++ for at least some uses of each pattern. - [Peter Norvig](http://norvig.com/design-patterns/design-patterns.pdf)

While recognizing different scales of patterns is critical, they can't be totally ordered by scale. The debate around patterns-as-flaws in programming languages appears to make this mistake: claiming superiority by demonstrating that some patterns are so small in scale as to be irrelevant. This school of thought then claims that the patterns at their scale and above are not indeed patterns, because they have no use of patterns.

This thinking is flawed in two ways. The glaring flaw is in the restrictive definition of patterns. The more subtle flaw is in not recognizing that they have patterns of their own at similar scales to the ones that were rejected. Abstraction is extremely powerful, but operating at higher levels of abstraction doesn't appear to imply higher productivity or reduced needs for patterns as a medium for sharing context.

